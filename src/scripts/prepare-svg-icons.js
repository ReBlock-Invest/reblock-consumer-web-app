/**
 * Reformat SVG Files
 */
const fs = require('fs');
const path = require('path');
const xml2js = require('xml2js');

const scriptPath = __dirname;
const folderPath = path.join(scriptPath, '../assets/icons'); 

fs.readdir(folderPath, (err, files) => {
  if (err) {
    console.error('Error reading folder:', err);
    return;
  }

  files.forEach((file) => {
    if (path.extname(file) === '.svg') {
      const filePath = path.join(folderPath, file);

      fs.readFile(filePath, 'utf8', (err, data) => {
        if (err) {
          console.error('Error reading file:', err);
          return;
        }

        xml2js.parseString(data, (err, result) => {
          if (err) {
            console.error('Error parsing SVG:', err);
            return;
          }

          const svg = result.svg;
          if (svg) {
            // Remove the style property on path tags
            if (svg.g && svg.g.length > 0 && svg.g[0].path) {
              if (!file.startsWith('ic-colored')) {
                svg.g[0].path.forEach((path) => {
                  if (path.$.style) {
                    path.$.style = undefined;
                  }
                });
              }              
            }

            // Change the viewBox property on svg tag
            if (svg.$.viewBox) {
              svg.$.viewBox = '64 64 896 896';
            }

            // Add fill="currentColor" property to svg tag
            svg.$.fill = 'currentColor';

            // Check if width and height properties are correct
            if (svg.$.width !== '896px' || svg.$.height !== '896px') {
              throw new Error(`Invalid width/height in ${file}`);
            }

            const builder = new xml2js.Builder();
            const modifiedSvg = builder.buildObject(result);

            // Write the modified SVG back to the file
            fs.writeFileSync(filePath, modifiedSvg);

            console.log(`Successfully edited ${file}`);
          }
        });
      });
    }
  });
});


/**
 * Add Icon to ReblockIcon component
 */
const camelCase = require('camelcase');

const svgDirectory = path.join(__dirname, '../assets/icons');

const importTemplate = (filename, variableName) => `import {ReactComponent as ${variableName}} from 'assets/icons/${filename}';\n`;

const svgFiles = fs.readdirSync(svgDirectory).filter(file => file.endsWith('.svg'));

const importStatements = svgFiles.map((filename) => {
  const variableName = camelCase(path.parse(filename).name, { pascalCase: true });
  return importTemplate(filename, variableName);
}).join('');

const iconMapEntries = svgFiles.map((filename) => {
  const variableName = camelCase(path.parse(filename).name, { pascalCase: true });
  const iconName = path.parse(filename).name.replace(".svg", "").replace("ic-", "")
  return `  "${iconName}": ${variableName},\n`;
}).join('');

const newContent = `/**
 * DO NOT EDIT THIS FILE. THIS FILE IS AUTO-GENERATED.
 * Read "src/assets/icons/README.md" for mor detail about how to add icons.
 */
import React, { CSSProperties } from "react"
import Icon from '@ant-design/icons'

${importStatements}

const IconMap = {
${iconMapEntries}
}

export type ReblockIconName = keyof typeof IconMap

type Props = {
  name: ReblockIconName
  color?: CSSProperties["color"]
  size?: number
  style?: CSSProperties
}

const ReblockIcon: React.FC<Props> = ({name, size = 24, color, style}) => {

  const SvgIcon = IconMap[name];

  return (
    <Icon component={SvgIcon} style={{fontSize: \`${"${size}px"}\`, color, ...style}} />
  )
}

export default React.memo(ReblockIcon)
`;

const componentFilePath = path.join(__dirname, '../components/common/ReblockIcon.tsx');

fs.writeFileSync(componentFilePath, newContent, 'utf8');
console.log('SVG files imported and added to IconMap.');